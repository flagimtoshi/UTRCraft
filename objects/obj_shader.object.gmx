<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_banner</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_solid</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
switch(shader)
{

case 0:
// nothing
break;

case 1:
if! ((object_index=obj_plattform) or (object_index=obj_glass) or (object_index=obj_door_close)){
draw_sprite_ext(spr_bs_high,0,x,y,0.1,0.1,0,c_black,1);
}//else{
//draw_sprite_ext(spr_bs_high,0,x,y,0.1,0.1/4,0,c_black,1);
//}

if object_index=obj_grass{
draw_sprite_ext(spr_extra_shad,0,x,y,1,1,0,colour,1);
lightning_shader(0,spr_extra_shad);
}
if object_index=obj_leaves{
draw_sprite(spr_extra_shad,1,x,y);
lightning_shader(1,spr_extra_shad);
}
if object_index=obj_haybale{
draw_sprite(spr_extra_shad,8,x,y);
lightning_shader(8,spr_extra_shad);
}
if object_index=obj_hard_block{
draw_sprite_ext(spr_extra_thicc_shad,0,x,y,1,1,0,c_black,1);

}
if object_index=obj_leaves{

}
if object_index=obj_glass{

}
/*if object_index=obj_dirt{
draw_sprite(spr_extra_shad,4,x,y);
lightning_shader(4,spr_extra_shad);

}*/
//op=instance_create(x+4,y+4,obj_player_head_minecraft)


break;

case 2:
draw_sprite(spr_block_shading,0,x,y);
break;

case 3:
//draw_sprite(spr_block_shading,1,x,y);
draw_sprite_ext(sprite_index,image_index,x-1,y-1,1.25,1.25,0,c_black,1);

break;

case 4:
draw_rectangle(x-1,y-1,x+7,y+7,1);
break;

case 5:
draw_sprite(spr_block_shading,2,x,y);
break;

case 6:

depth = floor(distance_to_point(obj_player.x, obj_player.y)*2)//abs(depth_x + depth_y);

visible=1

//                                                      create
X = 0
 Y = 1

//properties
height = 0.1// 0.1;

length = 8;
width = 8;

top_length = length * (1+height);
top_width = width * (1+height);

//sprites
sprite_face = sprite_index;

//                                                      draw
//Four arrays that will contain the locations of the four vertices

//of the two rectangles
var topLeft, topRight, bottomRight, bottomLeft;

//Calculate vertices of the base rectangle, 0
topLeft[0, X] = x+4 - length/2;
topLeft[0, Y] = y+4 - width/2;

topRight[0, X] = x+4 + length/2;
topRight[0, Y] = y+4 - width/2;

bottomRight[0, X] = x+4 + length/2;
bottomRight[0, Y] = y+4 + width/2;

bottomLeft[0, X] = x+4 - length/2;
bottomLeft[0, Y] = y+4 + width/2;

//Distance to camera center, so that the bigger rectangle can be offset
//for the 3D effect
var cam_x = view_xview-4-5*8//camera_get_view_x(view_camera);
var cam_y = view_yview-4-30//camera_get_view_y(view_camera);
var cam_w = view_wview//camera_get_view_width(view_camera);
var cam_h = view_hview//camera_get_view_height(view_camera);

var camCenter;
camCenter[X] = cam_x + cam_w/2;
camCenter[Y] = cam_y + cam_h/2;

//Calculate offset to camera center
var camOffset;
camOffset[X] = x - camCenter[X];
camOffset[Y] = y - camCenter[Y];

//Set center point of the bigger rectangle
var topPos;
topPos[X] = x + (camOffset[X] * height);
topPos[Y] = y + (camOffset[Y] * height);

//Calculate vertices of the bigger rectangle, 1
topLeft[1, X] = topPos[X] - top_length/2;
topLeft[1, Y] = topPos[Y] - top_width/2;

topRight[1, X] = topPos[X] + top_length/2;
topRight[1, Y] = topPos[Y] - top_width/2;

bottomRight[1, X] = topPos[X] + top_length/2;
bottomRight[1, Y] = topPos[Y] + top_width/2;

bottomLeft[1, X] = topPos[X] - top_length/2;
bottomLeft[1, Y] = topPos[Y] + top_width/2;

//Determine which faces are visible
var topVisible = topLeft[1, Y] &gt; topLeft[0, Y];
var rightVisible = topRight[1, X] &lt; topRight[0, X];
var bottomVisible = bottomLeft[1, Y] &lt; bottomLeft[0, Y];
var leftVisible = topLeft[1, X] &gt; topLeft[0, X];

//Draw the base sprite
//draw_sprite_pos(sprite_face, image_index, topLeft[0, X], topLeft[0, Y], topRight[0, X], topRight[0, Y], bottomRight[0, X], bottomRight[0, Y], bottomLeft[0, X], bottomLeft[0, Y], 1);

//Draw the other four faces
//Up
if ! place_meeting(x,y-1,obj_solid){
draw_sprite_pos(sprite_face, image_index, topLeft[1, X], topLeft[1, Y], topRight[1, X], topRight[1, Y], topRight[0, X], topRight[0, Y], topLeft[0, X], topLeft[0, Y], topVisible);
}
//Right
if ! place_meeting(x+1,y,obj_solid){
//draw_sprite_pos(sprite_face, image_index, topRight[0, X], topRight[0, Y], topRight[1, X], topRight[1, Y], bottomRight[1, X], bottomRight[1, Y], bottomRight[0, X], bottomRight[0, Y], rightVisible);
draw_set_colour(c_black)
draw_set_alpha(0.4)
draw_sprite_pos(sprite_face, image_index, topRight[0, X], topRight[0, Y], topRight[1, X], topRight[1, Y], bottomRight[1, X], bottomRight[1, Y], bottomRight[0, X], bottomRight[0, Y], rightVisible);
draw_set_colour(image_blend)
draw_set_alpha(1)}
//Down
if ! place_meeting(x,y+1,obj_solid){
//draw_sprite_pos(sprite_face, image_index, bottomLeft[0, X], bottomLeft[0, Y], bottomRight[0, X], bottomRight[0, Y], bottomRight[1, X], bottomRight[1, Y], bottomLeft[1, X], bottomLeft[1, Y], bottomVisible);
draw_set_colour(c_black)
draw_set_alpha(0.5)
draw_sprite_pos(sprite_face, image_index, bottomLeft[0, X], bottomLeft[0, Y], bottomRight[0, X], bottomRight[0, Y], bottomRight[1, X], bottomRight[1, Y], bottomLeft[1, X], bottomLeft[1, Y], bottomVisible);
draw_set_colour(image_blend)
draw_set_alpha(1)}
//Left
if ! place_meeting(x-1,y,obj_solid){
//draw_sprite_pos(sprite_face, image_index, topLeft[1, X], topLeft[1, Y], topLeft[0, X], topLeft[0, Y], bottomLeft[0, X], bottomLeft[0, Y], bottomLeft[1, X], bottomLeft[1, Y], leftVisible);
draw_set_colour(c_black)
draw_set_alpha(0.4)
draw_sprite_pos(sprite_face, image_index, topLeft[1, X], topLeft[1, Y], topLeft[0, X], topLeft[0, Y], bottomLeft[0, X], bottomLeft[0, Y], bottomLeft[1, X], bottomLeft[1, Y], leftVisible);
draw_set_colour(image_blend)
draw_set_alpha(1)}

//Draw the bigger rectangle sprite
draw_sprite_pos(sprite_face, image_index, topLeft[1, X], topLeft[1, Y], topRight[1, X], topRight[1, Y], bottomRight[1, X], bottomRight[1, Y], bottomLeft[1, X], bottomLeft[1, Y], 1);

//                              end Draw !!!!!!!!!!!!!!!!!!!!!!
visible=0
break;

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_entity</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw_sprite_ext(other.sprite_index,image_index,x-1,y-1,1.25,1.25,0,c_black,1);
/*switch(shader)
{

case 0:
// nothing
break;

case 1:
//draw_sprite_ext(spr_bs_high,0,x,y,0.1,0.1,0,c_black,1);
break;

case 2:
//draw_sprite(spr_block_shading,0,x,y);
break;

case 3:
draw_sprite(spr_block_shading,1,x,y);
break;

case 4:
draw_rectangle(x-1,y-1,x+7,y+7,1);
break;

case 5:
draw_sprite(spr_block_shading,2,x,y);
break;

}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
