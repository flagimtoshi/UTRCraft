<html lang="en"><head>
<meta charset="UTF-8">
<title>Window Freeze Fix cheat sheet</title>
<meta name="viewport" content="width=device-width" />
<meta name="livenode" content="#doc" />
<meta property="theme-color" content="#FFF037" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_us" />
<meta property="og:site_name" content="YellowAfterlife" />
<meta property="og:title" content="Window Freeze Fix cheat sheet" />
<script type="text/javascript">
if (document.location.host == "yal.cc" && location.protocol == "http:") {
	document.location.protocol = "https:";
}
</script>
<style type="text/css">body, #doc tt {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	margin: 0;
}
.main {
	width: 100%;
	min-height: 100%;
	min-height: 100vh;
	background-color: #899FC6;
}
.page {
	max-width: 656px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	box-shadow: 0 0 8px rgba(0, 0, 0, 0.3);
	min-height: 100%;
	min-height: 100vh;
	box-sizing: border-box;
}
.page > p:first-child {
	margin-top: 0;
}
#doc, #doc ul, #doc ol {
	padding-left: 0;
	margin: 0;
}
#doc article > ul, #doc article > ol {
	padding-left: 20px;
}
#doc article ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc header {
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
}
#doc header a {
	outline: none;
	text-decoration: none;
	color: #458;
}
#doc header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	position: relative;
	top: -1px;
}
#doc section.open > header::before {
	content: "-";
}
#doc section.empty > header::before {
	content: " "; /*"Â·"*/
}
#doc header:hover {
	border-left-color: #f3f3f3;
	background: #f3f3f3;
}
#doc header .ret-arrow {
	font-weight: normal;
	margin: 0 0.1em;
}

#doc a.broken {
	color: red;
}
#doc p {
	margin: 0;
}
#doc p + p, #doc p.pad {
	margin-top: 0.5em;
}
#doc img {
	max-width: 100%;
}
#doc h3 {
	margin: 0.25em 0;
	font-size: 125%;
	font-weight: normal;
	border-bottom: 1px solid #ccc;
}

#doc article, #doc ul {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc article {
	padding-top: 0.25em;
	padding-bottom: 0.5em;
}
#doc tt {
	font-weight: bold;
}
#doc table {
	border-spacing: 0;
	color: currentColor;
}
#doc table, #doc table td, #doc table th {
	border: 1px solid #f3f3f3;
}
#doc table td, #doc table th {
	padding: 0.1em 0.5em;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	-moz-tab-size: 4;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a.uf {
	background-color: #f7f0ff;
}
#doc pre a.kw {
	background-color: #f0f7ff;
}
#doc pre a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	-webkit-text-decoration-color: #bbb;
	text-decoration-color: #bbb;
	-webkit-text-decoration-style: double;
	text-decoration-style: double;
}
#doc hr {
	margin: 0.5em 0;
	margin-right: 1em;
	border: 0;
	border-top: 2px dashed #f3f3f3;
}
#doc section + hr {
	margin: 0;
	height: 1em;
	border: 1px solid #f3f3f3;
	border-width: 1px 0 1px 0;
}
#doc section {
	border-top: 1px solid #f3f3f3;
	margin-top: 0.3em;
}
#doc section:first-child {
	margin-top: 0em;
}
#doc section:last-child {
	border-bottom: 1px solid #f3f3f3;
}
#doc section + section, #doc hr + section {
	border-top: 0;
	margin-top: 0;
}
#doc section + p {
	border-top: 1px solid #f3f3f3;
	padding-top: 0.3em;
}
/* delay display until load */
#doc[ready] section:not(.open) > article {
	display: none;
}</style>
<style type="text/css" id="lang_gml">/* GameMakerLanguage */
pre.gmlmd .md { color: #7A81A9 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #00f } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */

#night:checked + .main pre.gmlmd .op { color: #CCCCCC }
#night:checked + .main pre.gmlmd .co { color: #5B995B }
#night:checked + .main pre.gmlmd .kw { color: #FFB871 }
#night:checked + .main pre.gmlmd .md { color: #FFB871 }
#night:checked + .main pre.gmlmd .cb { color: #FFB871 }
#night:checked + .main pre.gmlmd .sf { color: #FFB871 }
#night:checked + .main pre.gmlmd .uf { color: #FFB871 }
#night:checked + .main pre.gmlmd .nu { color: #FF8080 }
#night:checked + .main pre.gmlmd .st { color: #FCF320 }
#night:checked + .main pre.gmlmd .ts { color: #FF8080 }
#night:checked + .main pre.gmlmd .sv { color: #FF8080 }
#night:checked + .main pre.gmlmd .gv { color: #FF80FF }
#night:checked + .main pre.gmlmd .ri { color: #FF8080 }
#night:checked + .main pre.gmlmd .lv { color: #FFF899 }
#night:checked + .main pre.gmlmd .uv { color: #B2B1FF }
#night:checked + .main pre.gmlmd .fd { color: #B2B1FF }

#night:checked + .main pre.gmlmd a.uf,
#night:checked + .main pre.gmlmd a.kw,
#night:checked + .main pre.gmlmd a.sf {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.sv {
	background-color: #422;
}</style>
<style type="text/css" id="night_css">#night { display: none }
label[for="night"] {
	color: blue;
	text-decoration: underline;
	cursor: pointer;
}
#night:checked + .main {
	background-color: #405070;
}
#night:checked + .main .page {
	background-color: #1A202D;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
	color: white;
}
#night:checked + .main a,
#night:checked + .main a:visited,
#night:checked + .main #doc header,
#night:checked + .main label[for="night"] {
	color: #9DEC76;
}
#night:checked + .main #doc header:before,
#night:checked + .main #doc h3 {
	border-color: #9DEC76
}
#night:checked + .main #doc header,
#night:checked + .main #doc header:hover,
#night:checked + .main #doc article,
#night:checked + .main #doc section,
#night:checked + .main #doc section + p,
#night:checked + .main #doc hr,
#night:checked + .main #doc ul,
#night:checked + .main #doc table,
#night:checked + .main #doc table td,
#night:checked + .main #doc table th
{
	border-color: rgba(205,225,255,0.1);
}
#night:checked + .main #doc header:hover,
#night:checked + .main #doc .asset:hover {
	background: rgba(205,225,255,0.1);
}
#night:checked + .main article ul li {
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px" fill="white"/></svg>'); 
}
#night:checked + .main pre {
	color: #cccccc;
	background: #000000;
	border: 1px solid #3E4757;
}</style>
<style>
.main.boxtt #doc tt {
	display: inline-block;
	background: #FFFBE4;
	font-family: Consolas, Ubuntu Mono, Dejavu Sans Mono, Lucida Console, monospace;
	font-weight: normal;
	font-size: 12px;
	line-height: 16px;
	padding: 0 2px;
	border: 1px solid #E6E0C4;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	max-width: 100%;
	word-break: break-word;
}
#night:checked + .main.boxtt #doc tt {
	background-color: #000;
	border-color: #5b7c9f;
	color: white;
}
</style>
<style type="text/css" id="print_css">@media print {
	.main { background-color: transparent }
	.display-controls { display: none; }
	.page { width: 100%; box-shadow: none; }
	#doc header::before,
	#doc section.open header::before	{
		content: "~";
	}
	#doc { display: inherit }
	#doc section:not(.open) > article,
	#doc[ready] section:not(.open) > article {
		display: inherit;
	}
}</style>
<noscript><style>#doc header::before {
	content: "~";
}
#doc header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc section:not(.open) > article {
	display: inherit;
}</style></noscript>
</head><body>
<input type="checkbox" id="night" checked/>
<div class="main boxtt">
<script type="text/javascript">(function() {
	var night = document.getElementById("night");
	var path = "docmd night mode";
	var ls = window.localStorage;
	if (ls) {
		night.checked = ls.getItem(path) == "true";
		night.onchange = function(_) {
			ls.setItem(path, "" + night.checked);
		};
	}
})();</script>
<main class="page">
<p>This is a "cheat sheet" for Window Freeze Fix extension by YellowAfterlife.  <br/>

The extension can be downloaded from <a href="https://yellowafterlife.itch.io/window-freeze-fix">itch.io</a>.  <br/>

Source code can be found on <a href="https://github.com/YAL-GameMaker/window_frame">GitHub</a>.  <br/>

An up-to-date version of this document can always be found <a href="https://yal.cc/docs/gm/window_freeze_fix">online</a>.</p><p class="display-controls">
Click on sections to expand/collapse them.<br>Quick display controls: <a href="#" onclick="opt_none(); return false">Categories</a>
&middot; <a href="#" onclick="opt_list(); return false">Sections</a>
&middot; <a href="#" onclick="opt_all(); return false">Everything</a>
&middot; <label for="night">Toggle night mode</label><br/>
</p><section id="doc">
<!--<doc--><p><section><header id="premise"><a href="#premise" title="(permalink)">Premise</a></header><article><p>
	This extension eliminates a certain caveat in GameMaker where the window ceases operation while
	being dragged around.
	</p><p>
	This can be desirable for applications that should not be easily interrupted.
</p></article></section><section><header id="setup"><a href="#setup" title="(permalink)">Setting up</a></header><article><ol>
		<li>	Enable "Borderless window" in Game Options - Windows - Graphics (GMS2)
			or Global Game Settings - Windows - Graphics (GMS1).
		</li><li>	Import the extension either directly (<tt>gmez</tt> for GMS1, <tt>yymp</tt> for GMS2.2, <tt>yymps</tt> for GMS2.3+)
			or by picking Add Existing and taking it from the sample projects on GitHub.
		</li><li>	Call <tt>window_frame_update()</tt> in a Step event of a persistent object.
	</li></ol></article></section><section><header id="disclaimers"><a href="#disclaimers" title="(permalink)">Things To Be Aware Of</a></header><article><p>
	Since the extension's initial release in 2017 it has been established
	that this isn't such a good idea: </p><ul>
		<li>	An extra window may break other extensions that rely on manipulating the game's window.
		</li><li>	Windows has various undocumented, buggy window behaviours.  <br/>

			For example, should you comment out the <tt>window_frame_force_focus</tt>
			call in <tt>window_frame.gml</tt>, after entering and exiting fullscreen something strange
			will happen to the frame window after the game's window is clicked, causing it to
			become unfocusable and unable to process window button (min/max/close) clicks.
		</li><li>	Various game overlays (such as Steam overlay) are big black boxes and do whatever
			they want - for example, it is possible to softlock your game by forcibly opening
			the overlay when the game does not react to the overlay shortcut.
		</li><li>	Use of an extra window breaks XInput gamepad polling, which is addressed by the second
			bundled extension.
		</li><li>	Use of an extra window also breaks DirectInput gamepad polling, which is not addressable
			unless you can figure out how GameMaker uses DirectInput API to hook the functions
			and enforce "global" polling mode.
		</li><li>	(probably more things that I forgot about)
	</li></ul><p>
	All in all, unless your application fits the narrow critera where above are acceptable
	sacrifices (read: it is probably <i>not</i> a videogame) <b>or</b> you have the intricate knowledge
	of WinAPI required to attempt resolving these issues, I suggest that you <b>do not</b>
	use this extension.
</p></article></section><section><header id="Size-and-state"><a href="#Size-and-state" title="(permalink)">Size and state</a></header><article><section><header id="window_frame_update"><a href="#window_frame_update" title="(permalink)">window_frame_update()</a></header><article><p>
		Should be called once per frame.
		</p><p>
		Manages startup and sync (e.g. hiding/unhiding the frame as the game enters/exits fullscreen).
	</p></article></section><hr/><section><header id="window_frame_set_visible"><a href="#window_frame_set_visible" title="(permalink)">window_frame_set_visible(visible)</a></header><article><p>
		Turns the frame on/off.
	</p></article></section><section><header id="window_frame_get_visible"><a href="#window_frame_get_visible" title="(permalink)">window_frame_get_visible()&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Returns whether the frame is currently being shown.
	</p></article></section><hr/><section><header id="window_frame_set_fullscreen"><a href="#window_frame_set_fullscreen" title="(permalink)">window_frame_set_fullscreen(enable)</a></header><article><p>
		Enables or disables fullscreen.
		</p><p>
		You <i>must</i> use this in place of regular <tt>window_set_fullscreen</tt>
		or you may land yourself or your project's users in an unusual situation
		involving a fullscreen window that is click-through and cannot be minimized.
	</p></article></section><section><header id="window_frame_get_fullscreen"><a href="#window_frame_get_fullscreen" title="(permalink)">window_frame_get_fullscreen()&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Counterpart of the above function.
	</p></article></section><hr/><section><header id="window_frame_has_focus"><a href="#window_frame_has_focus" title="(permalink)">window_frame_has_focus()&#8203;<span class="ret-arrow">&#10140;</span>focus?</a></header><article><p>
		Equivalent to built-in <tt>window_has_focus</tt>, but counts the frame too.
	</p></article></section><section><header id="window_is_maximized"><a href="#window_is_maximized" title="(permalink)">window_is_maximized()&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Returns whether the window (or the frame) is formally maximized.
		</p><p>
		Note that occupying the entire display area is not the same as maximizing the window,
		and this will only change to <tt>true</tt> when clicking the "maximize" button
		or <a href="#window_command_run">invoking</a> the command.
	</p></article></section><hr/><section><header id="window_frame_get_x"><a href="#window_frame_get_x" title="(permalink)">window_frame_get_x()&#8203;<span class="ret-arrow">&#10140;</span>x</a></header><article><p>
		Returns X of either the frame (if visible) or the game window.
	</p></article></section><section><header id="window_frame_get_y"><a href="#window_frame_get_y" title="(permalink)">window_frame_get_y()&#8203;<span class="ret-arrow">&#10140;</span>y</a></header><article><p>
		Returns Y of either the frame (if visible) or the game window.
	</p></article></section><section><header id="window_frame_get_width"><a href="#window_frame_get_width" title="(permalink)">window_frame_get_width()&#8203;<span class="ret-arrow">&#10140;</span>width</a></header><article><p>
		Returns width of either the frame (if visible) or the game window.
	</p></article></section><section><header id="window_frame_get_height"><a href="#window_frame_get_height" title="(permalink)">window_frame_get_height()&#8203;<span class="ret-arrow">&#10140;</span>height</a></header><article><p>
		Returns height of either the frame (if visible) or the game window.
	</p></article></section><section><header id="window_frame_get_rect"><a href="#window_frame_get_rect" title="(permalink)">window_frame_get_rect()&#8203;<span class="ret-arrow">&#10140;</span>[x, y, w, h]</a></header><article><p>
		Returns a 4-element array containing x/y/width/height
		of either the frame (if visible) or the game window.
	</p></article></section><section><header id="window_frame_set_rect"><a href="#window_frame_set_rect" title="(permalink)">window_frame_set_rect(x, y, w, h)</a></header><article><p>
		Equivalent to <tt>window_set_rectangle</tt>.
		</p><p>
		Will move either the frame (if active)
		or the actual game window.
	</p></article></section><hr/><section><header id="window_frame_set_min_size"><a href="#window_frame_set_min_size" title="(permalink)">window_frame_set_min_size(minWidth, minHeight)</a></header><article><p>
		If the frame is resizable, this function allows to specify minimum user-defined size.
		</p><p>
		For example,
		</p><pre class="gmlmd">
<a class="sf" href="#window_frame_set_min_size">window_frame_set_min_size</a><span class="op">(</span><span class="nu">224</span><span class="op">,</span> <span class="nu">192</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="window_frame_set_max_size"><a href="#window_frame_set_max_size" title="(permalink)">window_frame_set_max_size(maxWidth, maxHeight)</a></header><article><p>
		If the frame is resizable, this function allows to specify maximum user-defined size.
		</p><p>
		For example,
		</p><pre class="gmlmd">
<a class="sf" href="#window_frame_set_max_size">window_frame_set_max_size</a><span class="op">(</span><span class="nu">1600</span><span class="op">,</span> <span class="nu">900</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><hr/><section><header id="window_frame_set_region"><a href="#window_frame_set_region" title="(permalink)">window_frame_set_region(x, y, w, h)</a></header><article><p>
		If the frame is active, this moves and/or resizes the game window inside the frame.
		</p><p>
		From the sample project:
		</p><pre class="gmlmd">
<span class="co">// resize the game to fit the container window if it's visible</span>
<span class="co">// (if you don't do window resizing, you don't need this)</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#window_frame_get_visible">window_frame_get_visible</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">var</span> <span class="lv">w</span> <span class="op">=</span> <a class="sf" href="#window_frame_get_width">window_frame_get_width</a><span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">var</span> <span class="lv">h</span> <span class="op">=</span> <a class="sf" href="#window_frame_get_height">window_frame_get_height</a><span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">w</span> <span class="op">&gt;</span> <span class="nu">0</span> <span class="op">&amp;&amp;</span> <span class="lv">h</span> <span class="op">&gt;</span> <span class="nu">0</span> <span class="op">&amp;&amp;</span> <span class="sf">surface_exists</span><span class="op">(</span><span class="sv">application_surface</span><span class="op">)</span>
    <span class="op">&amp;&amp;</span> <span class="op">(</span><span class="sf">window_get_width</span><span class="op">(</span><span class="op">)</span> <span class="op">!=</span> <span class="lv">w</span> <span class="op">||</span> <span class="sf">window_get_height</span><span class="op">(</span><span class="op">)</span> <span class="op">!=</span> <span class="lv">h</span><span class="op">)</span>
    <span class="op">)</span> <span class="cb">{</span>
        <span class="co">// resize room (since we don't use views):</span>
        <span class="sv">room_width</span> <span class="op">=</span> <span class="lv">w</span><span class="op">;</span> <span class="sv">room_height</span> <span class="op">=</span> <span class="lv">h</span><span class="op">;</span>
        <span class="co">// resize the game inside the frame-window to fit it's size:</span>
        <a class="sf" href="#window_frame_set_region">window_frame_set_region</a><span class="op">(</span><span class="nu">0</span><span class="op">,</span> <span class="nu">0</span><span class="op">,</span> <span class="lv">w</span><span class="op">,</span> <span class="lv">h</span><span class="op">)</span><span class="op">;</span>
        <span class="co">// also resize application_surface:</span>
        <span class="sf">surface_resize</span><span class="op">(</span><span class="sv">application_surface</span><span class="op">,</span> <span class="lv">w</span><span class="op">,</span> <span class="lv">h</span><span class="op">)</span><span class="op">;</span>
    <span class="cb">}</span>
<span class="cb">}</span>
</pre></article></section></article></section><section><header id="Extras"><a href="#Extras" title="(permalink)">Extras</a></header><article><section><header id="window_frame_set_background"><a href="#window_frame_set_background" title="(permalink)">window_frame_set_background(color)</a></header><article><p>
		Sets the background color shown on the portions of the frame window not occupied by your game. Can be set to -1 to not draw anything there.
		</p><pre class="gmlmd">
<a class="sf" href="#window_frame_set_background">window_frame_set_background</a><span class="op">(</span><span class="uf">make_color_rgb</span><span class="op">(</span><span class="nu">136</span><span class="op">,</span> <span class="nu">158</span><span class="op">,</span> <span class="nu">197</span><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="window_frame_set_caption"><a href="#window_frame_set_caption" title="(permalink)">window_frame_set_caption(text)</a></header><article><p>
		Like <tt>window_set_caption</tt>, but for the frame.
	</p></article></section><section><header id="window_frame_sync_icons"><a href="#window_frame_sync_icons" title="(permalink)">window_frame_sync_icons()</a></header><article><p>
		If you are using extensions that change the window icon,
		you can call this function afterwards to carry them over to the frame window.
		</p><p>
		(note: copies raw <tt>HICON</tt> IDs, doesn't store bitmaps)
	</p></article></section><hr/><section><header id="window_set_topmost"><a href="#window_set_topmost" title="(permalink)">window_set_topmost(enable)</a></header><article><p>
		Changes whether the window (game or frame) will stay on top of other windows.
		</p><p>
		It is most likely possible to break something with this function and it should not
		generally be used in videogames.
	</p></article></section><section><header id="window_get_topmost"><a href="#window_get_topmost" title="(permalink)">window_get_topmost()&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Returns whether the window (game or frame) is currently marked as stay-on-top.
	</p></article></section><hr/></article></section><section><header id="window_command"><a href="#window_command" title="(permalink)">Window Commands block</a></header><article><p>
	The following mirror <a href="https://yellowafterlife.itch.io/gamemaker-window-commands">my other extension</a>:
	</p><p>
	Supported command constants: </p><ul>
	<li> <tt>window_command_close</tt>
	</li><li> <tt>window_command_maximize</tt>
	</li><li> <tt>window_command_minimize</tt>
	</li><li> <tt>window_command_restore</tt><br/>
		The button for un-maximizing the window.<br/>
		Disabling this can be generally considered somewhat evil.
	</li><li> <tt>window_command_resize</tt><br/>
		If disabled, the window cannot be resized.
	</li><li> <tt>window_command_move</tt><br/>
		If disabled, the window cannot be dragged around.
	</li><li> More command IDs can be found on
		<a href="https://docs.microsoft.com/en-us/windows/win32/menurc/wm-syscommand">MSDN</a>
		(used as <tt>0xF060</tt> etc.)
	</li></ul><p>
	State:
	</p><section><header id="window_command_set_active"><a href="#window_command_set_active" title="(permalink)">window_command_set_active(command, enable)&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Enables or disables a command.<br/>
		For example, for buttons this grays out the button.
		</p><p>
		Returns whether succeeded.
		</p><p>
		Fails if the extension doesn't have a meaningful way of disabling the said command
		(in which case you should use hooks instead).
		</p><p>
		So
		</p><pre class="gmlmd">
<a class="sf" href="#window_command_set_active">window_command_set_active</a><span class="op">(</span><span class="uv">window_command_minimize</span><span class="op">,</span> <span class="nu">0</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		would disable the ability to minimize the window.
		</p><p>
		Note that a disabled (or hooked) command can still be ran via <a href="#window_command_run">window_command_run</a>.
	</p></article></section><section><header id="window_command_get_active"><a href="#window_command_get_active" title="(permalink)">window_command_get_active(command)&#8203;<span class="ret-arrow">&#10140;</span>enabled?</a></header><article><p>
		Returns whether a command is currently enabled, or -1 if unknown.
	</p></article></section><p>
	Hooks:
	</p><section><header id="window_command_hook"><a href="#window_command_hook" title="(permalink)">window_command_hook(command)</a></header><article><p>
		Hooks the specified command, intercepting the action and allowing you to check
		for it using <a href="#window_command_check">window_command_check</a>. Only button-commands can be hooked.
	</p></article></section><section><header id="window_command_unhook"><a href="#window_command_unhook" title="(permalink)">window_command_unhook(command)</a></header><article><p>
		Un-hooks the specified command, allowing it to be performed as usual.
	</p></article></section><section><header id="window_command_set_hooked"><a href="#window_command_set_hooked" title="(permalink)">window_command_set_hooked(command, enable)</a></header><article><p>
		A convenience function for two of above.
	</p></article></section><section><header id="window_command_get_hooked"><a href="#window_command_get_hooked" title="(permalink)">window_command_get_hooked(command)&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Returns whether the specified command is currently hooked.
	</p></article></section><section><header id="window_command_check"><a href="#window_command_check" title="(permalink)">window_command_check(command)&#8203;<span class="ret-arrow">&#10140;</span>was pressed?</a></header><article><p>
		Returns whether the given command's button was pressed since the last call to this function.
	</p></article></section><p>
	Invocation:
	</p><section><header id="window_command_run"><a href="#window_command_run" title="(permalink)">window_command_run(wParam, lParam = 0)</a></header><article><p>
		Runs the specified command, regardless of whether it is currently hooked.
		</p><p>
		This essentially invokes <a href="https://docs.microsoft.com/en-us/windows/win32/menurc/wm-syscommand">WM_SYSCOMMAND</a> on the frame.
		</p><p>
		<tt>lParam</tt> is optional since for most (all?) commands it contains the mouse coordinates
		and is not used by the command processor.
		</p><p>
		So
		</p><pre class="gmlmd">
<a class="sf" href="#window_command_run">window_command_run</a><span class="op">(</span><span class="uv">window_command_minimize</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		would minimize the window when invoked.
		</p><p>
		<b>NB!</b> Many commands cannot be ran if a mouse button is currently being held down on the window.
		You'll want to either run commands on <tt>mouse_check_button_released</tt> or set a flag on press
		and wait for release.
	</p></article></section></article></section><section><header id="exotic"><a href="#exotic" title="(permalink)">Exotic functions</a></header><article><section><header id="window_frame_set_fakefullscreen"><a href="#window_frame_set_fakefullscreen" title="(permalink)">window_frame_set_fakefullscreen(enable)</a></header><article><p>
		<a href="https://github.com/time-killer-games">Samuel</a>'s borderless fullscreen implementation
		for the video player extension.
		</p><p>
		I <i>think</i> this implies disabling the frame yourself beforehand.
	</p></article></section><section><header id="window_frame_get_fakefullscreen"><a href="#window_frame_get_fakefullscreen" title="(permalink)">window_frame_get_fakefullscreen()&#8203;<span class="ret-arrow">&#10140;</span>bool</a></header><article><p>
		Counterpart of above function.
	</p></article></section><hr/><section><header id="window_frame_get_handle"><a href="#window_frame_get_handle" title="(permalink)">window_frame_get_handle(buffer_addr)</a></header><article><p>
		Takes a <tt>buffer_get_address</tt> of a buffer and pokes the frame's HWND to
		beginning of it as <tt>buffer_u64</tt>.
		</p><p>
		Rest assured, the buffer should be at least 8 bytes long or your game will hard crash.
	</p></article></section><section><header id="window_frame_get_wid"><a href="#window_frame_get_wid" title="(permalink)">window_frame_get_wid()&#8203;<span class="ret-arrow">&#10140;</span>string</a></header><article><p>
		Returns the frame's HWND (a 64-bit integer) <i>as a string</i>.
		</p><p>
		You should subsequently call <tt>int64</tt> on the result to convert it to an actual int64.
	</p></article></section></article></section></p><!--doc>-->
</section></main></div>
<script type="text/javascript">(function() {
	var doc, headers;
	//
	var path = "Window Freeze Fix cheat sheet";
	var state = null;
	if (window.localStorage && JSON.parse) {
		state = window.localStorage.getItem(path);
		state = state ? JSON.parse(state) : { };
		if (state == null) state = { };
	}
	var isLocal = (location.host.indexOf("localhost") == 0);
	//
	function h3bind(h3) {
		var node = h3.parentNode;
		var snip = node.children[1];
		var id = h3.id || h3.textContent;
		h3.snip = snip;
		h3.doc_set = function(z) {
			if (z) node.classList.add("open"); else node.classList.remove("open");
			if (state) {
				state[id] = z;
				window.localStorage.setItem(path, JSON.stringify(state));
			}
		}
		h3.doc_hide = function() {
			this.doc_set(false);
		}
		h3.doc_show = function() {
			this.doc_set(true);
		}
		h3.onclick = function(_) {
			var seen = !node.classList.contains("open");
			h3.doc_set(seen);
			return false;
		};
	}
	function getHashFunc(id) {
		var node = document.getElementById(id);
		if (node == null) return null;
		return function(e) {
			while (node && node != doc) {
				if (node.classList.contains("item")) {
					node.classList.add("open");
				}
				node = node.parentElement;
			}
		};
	}
	// Display helpers:
	window.opt_none = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
	};
	window.opt_list = function() {
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			if (h3.parentNode.parentNode != doc) {
				h3.doc_hide();
			} else h3.doc_show();
		}
	};
	window.opt_all = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_show();
	};
	window.live_post = function() {
		doc = document.getElementById("doc");
		headers = doc.getElementsByTagName("header");
		//
		for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
		// Clicks in document expand the related section:
		var anchors = doc.getElementsByTagName("a");
		for (var i = 0; i < anchors.length; i++) {
			var anchor = anchors[i];
			if (anchor.classList.contains("header")) continue;
			var href = anchor.getAttribute("href");
			if (href[0] == "#") {
				var fn = getHashFunc(href.substr(1));
				if (!fn) {
					anchor.classList.add("broken");
					anchor.title = "(section missing)";
				} else anchor.addEventListener("click", fn);
			}
		}
		//
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			var val = state ? state[h3.id || h3.textContent] : null;
			if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
			if (val) h3.doc_show(); else h3.doc_hide();
		}
	};
	window.live_post();
	//
	(function() {
		var hash = document.location.hash;
		if (hash) {
			var _hash = hash.substr(1);
			getHashFunc(_hash)();
			setTimeout(function() {
				document.location.hash = hash + " ";
				setTimeout(function() {
					document.location.hash = hash;
				}, 100);
			}, 100);
		}
	})();
	//
	doc.setAttribute("ready", "");
	})();</script>
</body></html>
